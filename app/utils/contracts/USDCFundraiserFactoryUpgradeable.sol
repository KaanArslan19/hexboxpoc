// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "./USDCFundraiserUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/proxy/Clones.sol";

// Interface for ProductToken minting/burning
interface IProductToken {
    function mint(address to, uint256 productId, uint256 amount) external;
    function burn(address from, uint256 productId, uint256 amount) external;
}

contract USDCFundraiserFactoryUpgradeable is Initializable, OwnableUpgradeable, UUPSUpgradeable {
    using Clones for address;

    uint256 public constant BASIS_POINTS = 10000; // 100% = 10000 basis points
    address public usdcAddress;
    address public productTokenAddress;
    uint256 public defaultFeePercentage;
    address public feeWallet;
    
    // Implementation contract address for USDCFundraiser
    address public fundraiserImplementation;
    
    // Array to track all deployed fundraisers
    address[] public deployedFundraisers;
    mapping(address => bool) public isFundraiser;
    
    event FundraiserCreated(address indexed fundraiser, address indexed creator);
    event ImplementationUpdated(address indexed newImplementation);
    event ProductTokenUpdated(address indexed newProductToken);
    event ProductIdMapped(
        address indexed fundraiser, 
        uint256 indexed originalProductId, 
        uint256 indexed uniqueProductId
    );
    
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(
        address _usdcAddress,
        address _productTokenAddress,
        uint256 _defaultFeePercentage,
        address _feeWallet,
        address _fundraiserImplementation,
        address _initialOwner
    ) public initializer {
        __Ownable_init(_initialOwner);
        __UUPSUpgradeable_init();
        
        require(_usdcAddress != address(0), "Invalid USDC address");
        require(_productTokenAddress != address(0), "Invalid product token address");
        require(_feeWallet != address(0), "Invalid fee wallet");
        require(_fundraiserImplementation != address(0), "Invalid implementation");
        require(_initialOwner != address(0), "Invalid owner");
        
        usdcAddress = _usdcAddress;
        productTokenAddress = _productTokenAddress;
        defaultFeePercentage = _defaultFeePercentage;
        feeWallet = _feeWallet;
        fundraiserImplementation = _fundraiserImplementation;
    }

    /**
    * @dev Create a new fundraiser campaign
    * @param beneficiaryWallet The wallet to receive raised funds
    * @param fundingType The funding type (0: All or Nothing, 1: Limitless)
    * @param minimumTarget The minimum target amount for the campaign
    * @param deadline The deadline for the campaign
    * @param products The array of products for the campaign
    */
    function createFundraiser(
        address beneficiaryWallet,
        uint256 fundingType,
        uint256 minimumTarget,
        uint256 deadline,
        ProductConfig[] memory products
    ) external returns (address) {
        require(beneficiaryWallet != address(0), "Invalid beneficiary");
        require(deadline > block.timestamp, "Invalid deadline");
        require(products.length > 0, "No products");

        address campaignAdmin = msg.sender;

        // Deploy minimal proxy clone of the implementation
        address fundraiserClone = fundraiserImplementation.clone();
        
        // Initialize the clone with factory address
        // Pass original product configs - fundraiser will generate unique IDs internally
        USDCFundraiserUpgradeable(fundraiserClone).initialize(
            usdcAddress,
            beneficiaryWallet,
            feeWallet,
            defaultFeePercentage,
            fundingType,
            minimumTarget,
            deadline,
            productTokenAddress,
            address(this),  // Pass factory address for minting/burning
            products,  // Pass original products, not pre-hashed
            campaignAdmin,
            owner() // Factory owner becomes the fundraiser owner
        );
        
        // Emit mapping events for frontend after initialization
        for (uint256 i = 0; i < products.length; i++) {
            // Get the unique product ID that was generated by the fundraiser
            uint256 uniqueProductId = USDCFundraiserUpgradeable(fundraiserClone).getUniqueProductId(products[i].productId);
            
            // Emit event to help frontend map original ID to unique ID
            emit ProductIdMapped(fundraiserClone, products[i].productId, uniqueProductId);
        }

        // Track the deployed fundraiser
        deployedFundraisers.push(fundraiserClone);
        isFundraiser[fundraiserClone] = true;

        emit FundraiserCreated(fundraiserClone, msg.sender);
        return fundraiserClone;
    }

    /**
     * @dev Allows authorized fundraisers to mint tokens through the factory
     * @param to Address to mint tokens to
     * @param productId Product ID to mint
     * @param amount Amount to mint
     * @notice Only fundraisers created by this factory can call this function
     * @notice Factory must have MINTER_ROLE on ProductToken
     */
    function mintForFundraiser(address givenProductTokenAddress, address to, uint256 productId, uint256 amount) external {
        require(isFundraiser[msg.sender], "Only fundraisers can mint");
        IProductToken(givenProductTokenAddress).mint(to, productId, amount);
    }

    /**
     * @dev Allows authorized fundraisers to burn tokens through the factory
     * @param from Address to burn tokens from
     * @param productId Product ID to burn
     * @param amount Amount to burn
     * @notice Only fundraisers created by this factory can call this function
     * @notice Factory must have MINTER_ROLE on ProductToken
     */
    function burnForFundraiser(address givenProductTokenAddress, address from, uint256 productId, uint256 amount) external {
        require(isFundraiser[msg.sender], "Only fundraisers can burn");
        IProductToken(givenProductTokenAddress).burn(from, productId, amount);
    }

    /**
    * @dev Change the default fee percentage
    * @param newFeePercentage The new fee percentage (basis points)
    */
    function changeDefaultFeePercentage(uint256 newFeePercentage) external onlyOwner {
        require(newFeePercentage < BASIS_POINTS, "Fee percentage must be less than 100%");
        defaultFeePercentage = newFeePercentage;
    }

    /**
    * @dev Change the fee wallet
    * @param newFeeWallet The new fee wallet address
    */
    function changeFeeWallet(address newFeeWallet) external onlyOwner {
        require(newFeeWallet != address(0), "Invalid fee wallet");
        feeWallet = newFeeWallet;
    }

    /**
    * @dev Update the fundraiser implementation
    * @param newImplementation The new implementation address
    */
    function updateFundraiserImplementation(address newImplementation) external onlyOwner {
        require(newImplementation != address(0), "Invalid implementation");
        fundraiserImplementation = newImplementation;
        emit ImplementationUpdated(newImplementation);
    }
    
    /**
     * @dev Updates the product token address
     * @param newProductToken The address of the new product token contract
     * @notice Only the owner can update the product token address
     * @notice This only affects new fundraiser deployments, not existing ones
     */
    function updateProductTokenAddress(address newProductToken) external onlyOwner {
        require(newProductToken != address(0), "Invalid product token address");
        productTokenAddress = newProductToken;
        emit ProductTokenUpdated(newProductToken);
    }

    /**
    * @dev Get the fee wallet
    * @return The fee wallet address
    */
    function getFeeWallet() external view returns (address) {
        return feeWallet;
    }
    
    /**
    * @dev Get the deployed fundraisers count
    * @return The number of deployed fundraisers
    */
    function getDeployedFundraisersCount() external view returns (uint256) {
        return deployedFundraisers.length;
    }
    
    /**
    * @dev Get a deployed fundraiser by index
    * @param index The index of the fundraiser to retrieve
    * @return The address of the deployed fundraiser
    */
    function getDeployedFundraiser(uint256 index) external view returns (address) {
        require(index < deployedFundraisers.length, "Index out of bounds");
        return deployedFundraisers[index];
    }

    /**
    * @dev Authorize an upgrade to a new implementation
    * @param newImplementation The new implementation address
    */
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
}